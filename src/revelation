#!/usr/bin/env python

#
# Revelation 0.3.0 - a password manager for GNOME 2
# http://oss.wired-networks.net/revelation/
# $Id$
#
# Copyright (c) 2003-2004 Erik Grinaker
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#


import pygtk
pygtk.require("2.0")
import gtk, gnome, gnome.ui, revelation, os, os.path, sys, gobject, gc, gconf



class Revelation(revelation.ui.App):

	def __init__(self):
		revelation.ui.App.__init__(self)

		self.toolbar.button_new.connect("clicked", lambda w: self.file_new())
		self.toolbar.button_open.connect("clicked", lambda w: self.file_open())
		self.toolbar.button_save.connect("clicked", lambda w: self.file_save(self.file, self.password))
		self.toolbar.button_entry_add.connect("clicked", lambda w: self.entry_add())
		self.toolbar.button_entry_edit.connect("clicked", lambda w: self.entry_edit())
		self.toolbar.button_entry_remove.connect("clicked", lambda w: self.entry_remove())

		menucb = {
			"File/New"			: lambda w: self.file_new(),
			"File/Open..."			: lambda w: self.file_open(),
			"File/Save"			: lambda w: self.file_save(self.file, self.password),
			"File/Save As..."		: lambda w: self.file_save(None, None),
			"File/Revert"			: lambda w: self.file_revert(),
			"File/Change Password..."	: lambda w: self.change_password(),
			"File/Lock..."			: lambda w: self.file_lock(),
			"File/Import..."		: lambda w: self.file_import(),
			"File/Export..."		: lambda w: self.file_export(),
			"File/Close"			: lambda w: self.__cb_quit(),
			"File/Quit"			: lambda w: self.__cb_quit(),

			"Edit/Add Entry..."		: lambda w: self.entry_add(),
			"Edit/Edit"			: lambda w: self.entry_edit(),
			"Edit/Remove"			: lambda w: self.entry_remove(),
			"Edit/Undo"			: lambda w: self.undo(),
			"Edit/Redo"			: lambda w: self.redo(),
			"Edit/Cut"			: lambda w: self.clip_cut(),
			"Edit/Copy"			: lambda w: self.clip_copy(),
			"Edit/Paste"			: lambda w: self.clip_paste(),
			"Edit/Find..."			: lambda w: self.entry_find(),
			"Edit/Find Next"		: lambda w: self.__entry_find(self, revelation.data.SEARCH_NEXT),
			"Edit/Find Previous"		: lambda w: self.__entry_find(self, revelation.data.SEARCH_PREV),
			"Edit/Preferences"		: lambda w: revelation.dialog.Preferences(self).run()
		}

		for path, cb in menucb.items():
			self.if_menu.get_widget("<main>/" + path).connect("activate", cb)

		self.connect("delete_event", self.__cb_quit)
		self.connect("tree-popup", self.__cb_popup_tree)
		self.tree.connect("doubleclick", self.__cb_doubleclick_tree)


	def __cb_doubleclick_tree(self, widget, iter):
		if iter is not None and self.data.get_entry(iter).type != revelation.entry.ENTRY_FOLDER:
			self.entry_edit()


	def __cb_popup_tree(self, object, menuitems, iters):

		if len(iters) == 1:
			menuitems.append(("/Edit", None, "Edit the selected entry", lambda w,d: self.entry_edit(), 0, "<StockItem>", revelation.stock.STOCK_EDIT))

		if len(iters) > 0:
			menuitems.append(("/Remove", None, "Remove the selected entry", lambda w,d: self.entry_remove(), 0, "<StockItem>", revelation.stock.STOCK_REMOVE))

		if len(iters) < 2:
			menuitems.append(("/Add Entry...", None, "Create a new entry", lambda w,d: self.entry_add(), 0, "<StockItem>", revelation.stock.STOCK_ADD))

		# set up clipboard menu
		clipboardmenu = []

		if len(iters) > 0:
			clipboardmenu.append(("/Cut", "", "Cut the selected entry to the clipboard", lambda w,d: self.clip_cut(), 0, "<StockItem>", gtk.STOCK_CUT))
			clipboardmenu.append(("/Copy", "", "Copy the selected entry to the keyboard", lambda w,d: self.clip_copy(), 0, "<StockItem>", gtk.STOCK_COPY))

		if len(iters) < 2 and self.clipboard.has_contents():
			clipboardmenu.append(("/Paste", "", "Paste entry from clipboard", lambda w,d: self.clip_paste(), 0, "<StockItem>", gtk.STOCK_PASTE))

		if len(clipboardmenu) > 0:
			menuitems.append(("/sep1", None, None, None, 0, "<Separator>"))
			menuitems.extend(clipboardmenu)


	def __cb_quit(self, object = None, data = None):
		return gtk.TRUE ^ self.quit()


	def __entry_find(self, parent, direction = revelation.data.SEARCH_NEXT):
		self.finder.folders = self.gconf.get_bool("/apps/revelation/search/folders")
		self.finder.casesens = self.gconf.get_bool("/apps/revelation/search/casesens")
		self.finder.namedesc = self.gconf.get_bool("/apps/revelation/search/namedesc")

		match = self.finder.find(self.tree.get_active(), direction)

		if match == None:
			revelation.dialog.Error(parent, "No match found", "The string you searched for did not match any entries. Try using a different search-phrase.").run()
		else:
			self.tree.select(match)


	def __file_autosave(self):
		"Autosaves the current file, due to data modification"

		if self.file is None or self.password is None:
			return

		if not self.gconf.get_bool("/apps/revelation/file/autosave"):
			return

		self.file_save(self.file, self.password)


	def __file_load(self, datafile):
		"Loads data from a file into an entrystore"

		try:
			if datafile.handler is None:
				datafile.detect_type()

			datafile.check_file()

			dialog = revelation.dialog.Password(
				self, "Enter file password",
				"The file '" + datafile.file + "' is encrypted. Please enter the file password to open it."
			)

			entrystore = None

			while 1:

				# load datafile, ask for password if needed
				try:
					if datafile.needs_password() and datafile.password is None:
						dialog.run()
						datafile.password = dialog.entry_password.get_text()

					entrystore = datafile.load()

				except revelation.datahandler.PasswordError:
					datafile.password = None
					revelation.dialog.Error(
						self, "Incorrect password",
						"The password you entered for the file'" + datafile.file + "' was not correct."
					).run()

				except:
					dialog.destroy()
					raise

				else:
					dialog.destroy()
					break

		except revelation.datahandler.FormatError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Invalid file format",
				"The file '" + datafile.file + "' is not a valid data file."
			).run()

		except revelation.entry.EntryError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Unknown data",
				"The file '" + datafile.file + "' contained unknown data. It may have been created by a future version of Revelation, try upgrading to a newer version."
			).run()

		except revelation.datahandler.VersionError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Unknown data version",
				"The file '" + datafile.file + "' has a future version number - upgrade Revelation to a more recent version to open it."
			).run()

		except revelation.io.DetectError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Filetype autodetection failed",
				"The format of the file '" + datafile.file + "' could not be detected automatically. It may still be possible to open the file, try specifying the file type manually."
			).run()

		except IOError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Unable to open file",
				"The file '" + datafile.file + "' could not be opened. Make sure that the file exists, and that you have the proper permissions to open it."
			).run()

		except revelation.CancelError:
			dialog.destroy()
			raise revelation.CancelError

		else:
			return entrystore



	def __file_save(self, datafile):
		"Saves data to a file"

		try:
			if datafile.file != self.file and revelation.io.file_exists(datafile.file):
				revelation.dialog.FileOverwrite(self, datafile.file).run()


			if not datafile.needs_password():
				revelation.dialog.FileExportInsecure(self).run()

			elif datafile.password is None:
				try:
					dialog = revelation.dialog.Password(
						self, "Enter file password",
						"Please enter a password which will be used to encrypt the file. You will need this password to open the file at a later time.",
						gtk.FALSE, gtk.TRUE
					)

					dialog.run()
					datafile.password = dialog.entry_new.get_text()
					dialog.destroy()

				except revelation.CancelError:
					dialog.destroy()
					raise


			datafile.save(self.data)


		except IOError:
			revelation.dialog.Error(self, "Unable to write to file", "The file '" + datafile.file + "' could not be opened for writing. Make sure that you have the proper permissions to write to it.").run()
			self.statusbar.set_status("Save failed")
			return gtk.FALSE

		else:
			return gtk.TRUE



	def change_password(self):
		try:
			dialog = revelation.dialog.Password(
				self, "Enter new password",
				"Enter a new password for the current data file. The file must be saved before the new password is applied.",
				32, self.password != None, gtk.TRUE
			)

			while 1:
				dialog.run()

				if self.password != None and dialog.entry_password.get_text() != self.password:
					revelation.dialog.Error(dialog, "Incorrect password", "The password you entered as the current file password is incorrect.").run()

				else:
					self.password = dialog.entry_new.get_text()
					self.data.changed = gtk.TRUE
					self.statusbar.set_status("Password changed")
					break

		except revelation.CancelError:
			self.statusbar.set_status("Password change cancelled")

		dialog.destroy()


	def clip_copy(self):
		iters = self.data.filter_parents(self.tree.get_selected())
		self.clipboard.copy(self.data, iters)


	def clip_cut(self):
		iters = self.data.filter_parents(self.tree.get_selected())
		self.undoqueue.add_action(revelation.data.UNDO_ACTION_CUT, iters)
		self.clipboard.cut(self.data, iters)
		self.tree.unselect_all()


	def clip_paste(self):
		if not self.clipboard.has_contents():
			return

		iters = self.clipboard.paste(self.data, self.tree.get_active())
		self.undoqueue.add_action(revelation.data.UNDO_ACTION_PASTE, iters)
		self.tree.select(iters[0])


	def entry_add(self):
		try:
			entry = revelation.dialog.EditEntry(self, "Add entry").run()
			iter = self.data.add_entry(self.tree.get_active(), entry)

			self.undoqueue.add_action(revelation.data.UNDO_ACTION_ADD, iter)
			self.__file_autosave()
			self.tree.select(iter)
			self.statusbar.set_status("Added entry '" + entry.name + "'")

		except revelation.CancelError:
			self.statusbar.set_status("Add entry cancelled")


	def entry_edit(self):
		iter = self.tree.get_active()

		if iter == None:
			return

		try:
			entry = self.data.get_entry(iter)
			dialog = revelation.dialog.EditEntry(self, "Edit entry", entry)

			if entry.type == revelation.entry.ENTRY_FOLDER and self.data.iter_n_children(iter) > 0:
				dialog.set_typechange_allowed(gtk.FALSE)

			newentry = dialog.run()
			self.data.update_entry(iter, newentry)
			self.undoqueue.add_action(revelation.data.UNDO_ACTION_EDIT, iter, entry)
			self.__file_autosave()
			self.tree.select(iter)
			self.statusbar.set_status("Updated entry '" + newentry.name + "'")

		except revelation.CancelError:
			self.statusbar.set_status("Update entry cancelled")


	def entry_find(self):
		dialog = revelation.dialog.Find(self)
		dialog.entry_phrase.set_text(self.finder.string)
		dialog.dropdown.set_type(self.finder.type)

		while 1:
			response = dialog.run()
			self.finder.string = dialog.entry_phrase.get_text()
			self.finder.type = dialog.dropdown.get_type()

			if response == revelation.dialog.RESPONSE_NEXT:
				self.__entry_find(dialog, revelation.data.SEARCH_NEXT)

			elif response == revelation.dialog.RESPONSE_PREVIOUS:
				self.__entry_find(dialog, revelation.data.SEARCH_PREV)

			else:
				dialog.destroy()
				break


	def entry_remove(self):
		iters = self.tree.get_selected()

		if len(iters) == 0:
			return

		elif len(iters) == 1:
			entry = self.data.get_entry(iters[0])

			if entry.type == revelation.entry.ENTRY_FOLDER:
				pritext = "Really remove folder '" + entry.name + "'?"
				sectext = "By removing this folder you will also remove all accounts and folders it contains."

			else:
				pritext = "Really remove account '" + entry.name + "'?"
				sectext = "Please confirm that you wish to remove this account."

			statustext = "Removed entry '" + entry.name + "'"

		else:
			pritext = "Really remove the " + str(len(iters)) + " selected entries?"
			sectext = "By removing these entries you will also remove any entries they may contain."
			statustext = "Removed " + str(len(iters)) + " entries"


		if revelation.dialog.RemoveEntry(self, pritext, sectext).run() == gtk.TRUE:
			iters = self.data.filter_parents(iters)
			self.undoqueue.add_action(revelation.data.UNDO_ACTION_REMOVE, iters)

			for iter in iters:
				self.data.remove_entry(iter)

			self.__file_autosave()
			self.tree.unselect_all()
			self.statusbar.set_status(statustext)

		else:
			self.statusbar.set_status("Remove entry cancelled")


	def file_export(self):
		"Exports data to a foreign file format"

		try:
			file, handler = revelation.dialog.ExportFileSelector(self).run()
			datafile = revelation.io.DataFile(file, handler)
			self.__file_save(datafile)

		except revelation.CancelError:
			self.statusbar.set_status("Export cancelled")

		else:
			self.statusbar.set_status("Data exported to " + datafile.file)


	def file_import(self):
		"Imports data from a foreign file"

		try:
			file, handler = revelation.dialog.ImportFileSelector(self).run()
			datafile = revelation.io.DataFile(file, handler)
			entrystore = self.__file_load(datafile)

			if entrystore is None:
				return

		except revelation.CancelError:
			self.statusbar.set_status("Import cancelled")

		else:
			iters = self.data.import_entrystore(entrystore)
			self.undoqueue.add_action(revelation.data.UNDO_ACTION_IMPORT, iters)
			self.__file_autosave()
			self.statusbar.set_status("Data imported from " + datafile.file)


	def file_lock(self):
		"Locks the current data file"

		if self.password is None:
			return

		iter = self.tree.get_active()
		self.tree.set_model(None)
		self.dataview.clear()
		self.statusbar.set_status("File locked")

		dialog = revelation.dialog.Password(self, "Enter password to unlock file", "The current file has been locked. Please enter the file password to unlock it.")
		dialog.get_button(1).destroy()

		while 1:
			try:
				dialog.run()

				if dialog.entry_password.get_text() == self.password:
					break

				else:
					revelation.dialog.Error(dialog, "Incorrect password", "The password you entered was not correct. Please try again.").run()

			except revelation.CancelError:
				pass

		dialog.destroy()

		self.tree.set_model(self.data)
		self.tree.select(iter)
		self.statusbar.set_status("File unlocked")


	def file_new(self):
		"Opens a new file"

		if not self.save_changes("Save changes to current file?", "You have made changes which have not been saved. If you create a new file without saving, then these changes will be discarded."):
			self.statusbar.set_status("New file cancelled")
			return

		self.data.clear()
		self.undoqueue.clear()
		self.file = None
		self.statusbar.set_status("New file created")


	def file_open(self, file = None, password = None):
		"Opens a data file"

		try:
			if not self.save_changes("Save changes before opening?", "You have made changes which have not been saved. If you open another file without saving, then these changes will be discarded."):
				return

			if file is None:
				file = revelation.dialog.FileSelector(self, "Select file to open").run()

			datafile = revelation.io.DataFile(file, revelation.datahandler.Revelation, password)
			entrystore = self.__file_load(datafile)

			if entrystore is None:
				return

		except revelation.CancelError:
			self.statusbar.set_status("Open cancelled")

		else:
			self.data.clear()
			self.undoqueue.clear()
			self.data.import_entrystore(entrystore)

			self.file = datafile.file
			self.password = self.filepassword = datafile.password
			self.statusbar.set_status("Opened file " + datafile.file)


	def file_revert(self):
		"Reverts to the saved version of the file"

		if self.data.changed == gtk.TRUE and revelation.dialog.Hig(
			self, "Ignore unsaved changes?", "You have made changes which have not yet been saved. If you revert to the saved file then these changes will be lost.",
			gtk.STOCK_DIALOG_WARNING, [ [ gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL ], [ gtk.STOCK_REVERT_TO_SAVED, gtk.RESPONSE_OK ] ], 0
		).run() != gtk.RESPONSE_OK:
			return gtk.FALSE

		self.file_open(self.file, self.filepassword, gtk.TRUE)


	def file_save(self, file = None, password = None):
		"Saves a data file"

		try:
			if file is None:
				file = revelation.dialog.FileSelector(self, "Select file to save data to").run()

			datafile = revelation.io.DataFile(file, revelation.datahandler.Revelation, password)

			if self.__file_save(datafile) == gtk.TRUE:
				self.file = file
				self.password = self.filepassword = password
				self.statusbar.set_status("Data saved to file " + file)
				return gtk.TRUE

		except revelation.CancelError:
			self.statusbar.set_status("Save cancelled")
			return gtk.FALSE



	def save_changes(self, pritext, sectext):
		if self.data.changed == gtk.FALSE:
			return gtk.TRUE

		try:
			if revelation.dialog.SaveChanges(self, pritext, sectext).run() == gtk.TRUE and self.file_save(self.file, self.password) == gtk.FALSE:
				return gtk.FALSE

		except revelation.CancelError:
			return gtk.FALSE

		return gtk.TRUE


	def quit(self):
		if not self.save_changes("Save changes before quitting?", "You have made changes which have not been saved. If you quit without saving, then these changes will be discarded."):
			self.statusbar.set_status("Quit cancelled")
			return gtk.FALSE

		width, height = self.get_size()
		self.gconf.set_int("/apps/revelation/view/window-width", width)
		self.gconf.set_int("/apps/revelation/view/window-height", height)
		self.gconf.set_int("/apps/revelation/view/pane-position", self.hpaned.get_position())

		gtk.mainquit()
		return gtk.TRUE


	def redo(self):
		"Redo the previously undone operation"

		if not self.undoqueue.can_redo():
			return

		action = self.undoqueue.get_action(revelation.data.REDO)
		iters = self.undoqueue.redo()

		if len(iters) > 0:
			self.tree.select(iters[0])
		else:
			self.tree.unselect_all()

		self.statusbar.set_status(action.name.capitalize() + " redone")


	def run(self, file = None):
		if file != None:
			self.file_open(file)
		elif self.gconf.get_bool("/apps/revelation/file/autoload"):
			self.file_open(self.gconf.get_string("/apps/revelation/file/autoload_file"))

		gtk.main()


	def undo(self):
		"Attempts to undo the previous operation"

		if not self.undoqueue.can_undo():
			return

		action = self.undoqueue.get_action()
		iters = self.undoqueue.undo()

		if len(iters) > 0:
			self.tree.select(iters[0])
		else:
			self.tree.unselect_all()

		self.statusbar.set_status(action.name.capitalize() + " undone")



if __name__ == "__main__":
	gnome.init(revelation.APPNAME, revelation.APPNAME)
	os.umask(0077)

	file = None
	if len(sys.argv) > 1:
		file = os.path.abspath(sys.argv[1])

	app = Revelation()
	app.run(file)

