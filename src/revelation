#!/usr/bin/env python

#
# Revelation 0.3.0 - a password manager for GNOME 2
# http://oss.wired-networks.net/revelation/
# $Id$
#
# Copyright (c) 2003-2004 Erik Grinaker
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

import pygtk
pygtk.require("2.0")

import gtk, gnome, revelation, os, os.path, sys, gobject


class Revelation(revelation.widget.App):
	"Main application class"

	def __init__(self):
		gnome.init(revelation.APPNAME, revelation.APPNAME)

		revelation.widget.App.__init__(self, revelation.APPNAME)
		self.connect("file-changed", self.__cb_state_file)
		self.connect("delete_event", self.__cb_quit)

		gtk.window_set_default_icon_list(
			gtk.gdk.pixbuf_new_from_file(revelation.DATADIR + "/pixmaps/revelation.png"),
			gtk.gdk.pixbuf_new_from_file(revelation.DATADIR + "/pixmaps/revelation-16x16.png")
		)

		os.umask(0077)

		self.__init_facilities()

		self.__init_toolbar()
		self.__init_menu()
		self.__init_mainarea()
		self.__init_states()


	def __setattr__(self, name, value):
		"Customized attribute access"

		revelation.widget.App.__setattr__(self, name, value)

		# emit "file-changed" signal when setting self.file
		if name == "file":
			self.emit("file-changed")


	# private init methods
	def __init_facilities(self):
		"Sets up various application facilities"

		try:
			self.config	= revelation.data.Config()

		except revelation.data.ConfigError:
			revelation.dialog.Error(
				None, "Configuration error",
				"The Revelation configuration data could not be found in gconf. This indicates a fault in your installation, please re-install Revelation."
			).run()

			sys.exit(1)


		self.icons	= revelation.stock.IconFactory(self)
		self.data	= revelation.data.EntryStore()
		self.clipboard	= revelation.data.EntryClipboard()
		self.undoqueue	= revelation.data.UndoQueue(self.data)
		self.finder	= revelation.data.EntrySearch(self.data)

		self.clipboard.connect("copy", self.__cb_state_clipboard)
		self.clipboard.connect("cut", self.__cb_state_clipboard)

		self.undoqueue.connect("changed", self.__cb_state_undo)

		self.finder.connect("changed", self.__cb_state_find)


	def __init_mainarea(self):
		"Sets up the main application area"

		self.tree = revelation.ui.Tree(self.data)
		self.tree.connect("button_press_event", self.__cb_popup_tree)
		self.tree.connect("doubleclick", self.__cb_doubleclick_tree)
		self.tree.selection.connect("changed", self.__cb_entry_display)
		self.tree.selection.connect("changed", self.__cb_state_entry)
		scrolledwindow = revelation.widget.ScrolledWindow(self.tree)

		self.dataview = revelation.ui.DataView()
		alignment = gtk.Alignment(0.5, 0.4, 0, 0)
		alignment.add(self.dataview)

		self.hpaned = revelation.widget.HPaned(scrolledwindow, alignment, self.config.get("view/pane-position"))
		self.set_contents(self.hpaned)


	def __init_menu(self):
		"Sets up the application menu"

		menuitems = (
			("/_File",		None,			None,					None,							0,	"<Branch>"),
			("/File/_New",		"<Control>N",		"Create a new file",			lambda w,d: self.file_new(),				0,	"<StockItem>",	gtk.STOCK_NEW),
			("/File/_Open...",	"<Control>O",		"Open a file",				lambda w,d: self.file_open(),				0,	"<StockItem>",	gtk.STOCK_OPEN),
			("/File/sep1",		None,			None,					None,							0,	"<Separator>"),
			("/File/_Save",		"<Control>S",		"Save data to file",			lambda w,d: self.file_save(self.file, self.password),	0,	"<StockItem>",	gtk.STOCK_SAVE),
			("/File/Save _As...",	"<Shift><Control>S",	"Save data to different file",		lambda w,d: self.file_save(),				0,	"<StockItem>",	gtk.STOCK_SAVE_AS),
			("/File/_Revert",	None,			"Revert to the saved copy of the file",	lambda w,d: self.file_revert(),				0,	"<StockItem>",	gtk.STOCK_REVERT_TO_SAVED),
			("/File/sep2",		None,			None,					None,							0,	"<Separator>"),
			("/File/Change _Password...",	None,		"Change password of current file",	lambda w,d: self.change_password(),			0,	"<StockItem>",	revelation.stock.STOCK_PASSWORD),
			("/File/_Lock...",	"<Control>L",		"Lock the current data file",		lambda w,d: self.file_lock(),				0,	"<StockItem>",	revelation.stock.STOCK_LOCK),
			("/File/sep3",		None,			None,					None,							0,	"<Separator>"),
			("/File/_Import...",	None,			"Import data from a foreign file",	lambda w,d: self.file_import(),				0,	"<StockItem>",	revelation.stock.STOCK_IMPORT),
			("/File/_Export...",	None,			"Export data to a different format",	lambda w,d: self.file_export(),				0,	"<StockItem>",	revelation.stock.STOCK_EXPORT),
			("/File/sep4",		None,			None,					None,							0,	"<Separator>"),
			("/File/_Close",	"<Control>W",		"Close the application",		self.__cb_quit,						0, 	"<StockItem>",	gtk.STOCK_CLOSE),
			("/File/_Quit",		"<Control>Q",		"Quit the application",			self.__cb_quit,						0, 	"<StockItem>",	gtk.STOCK_QUIT),

			("/_Edit",		None,			None,					None,							0,	"<Branch>"),
			("/Edit/_Add Entry...",	"Insert",		"Create a new entry",			lambda w,d: self.entry_add(),				0,	"<StockItem>",	revelation.stock.STOCK_ADD),
			("/Edit/_Edit",		"Return",		"Edit the selected entry",		lambda w,d: self.entry_edit(),				0,	"<StockItem>",	revelation.stock.STOCK_EDIT),
			("/Edit/Re_move",	"Delete",		"Remove the selected entry",		lambda w,d: self.entry_remove(),			0,	"<StockItem>",	revelation.stock.STOCK_REMOVE),
			("/Edit/sep1",		None,			None,					None,							0,	"<Separator>"),
			("/Edit/_Undo",		"<Control>Z",		"Undo the last action",			lambda w,d: self.undo(),				0,	"<StockItem>",	gtk.STOCK_UNDO),
			("/Edit/_Redo",		"<Shift><Control>Z",	"Redo the previously undone action",	lambda w,d: self.redo(),				0,	"<StockItem>",	gtk.STOCK_REDO),
			("/Edit/sep2",		None,			None,					None,							0,	"<Separator>"),
			("/Edit/Cu_t",		"<Control>X",		"Cut the entry to the clipboard",	lambda w,d: self.clip_cut(),				0,	"<StockItem>",	gtk.STOCK_CUT),
			("/Edit/_Copy",		"<Control>C",		"Copy the entry to the clipboard",	lambda w,d: self.clip_copy(),				0,	"<StockItem>",	gtk.STOCK_COPY),
			("/Edit/_Paste",	"<Control>V",		"Paste entry from clipboard",		lambda w,d: self.clip_paste(),				0,	"<StockItem>",	gtk.STOCK_PASTE),
			("/Edit/sep3",		None,			None,					None,							0,	"<Separator>"),
			("/Edit/_Find...",	"<Control>F",		"Search for an entry",			lambda w,d: self.entry_find(),				0,	"<StockItem>",	gtk.STOCK_FIND),
			("/Edit/Find Ne_xt",	"<Control>G",		"Find the next search match",		lambda w,d: self.__entry_find(self, revelation.data.SEARCH_NEXT),	0,	"<Item>"),
			("/Edit/Find Pre_vious",	"<Shift><Control>G",		"Find the previous search match",	lambda w: self.__entry_find(self, revelation.data.SEARCH_PREV),	0,	"<Item>"),
			("/Edit/sep4",		None,			None,					None,							0,	"<Separator>"),
			("/Edit/_Select All",	"<Control>A",		"Select all entries",			lambda w,d: self.tree.select_all(),			0,	"<Item>"),
			("/Edit/_Deselect All",	"<Shift><Control>A",	"Deselect all entries",			lambda w,d: self.tree.unselect_all(),			0,	"<Item>"),
			("/Edit/sep5",		None,			None,					None,							0,	"<Separator>"),
			("/Edit/Prefere_nces",	None,			"Edit preferences",			lambda w,d: revelation.dialog.Preferences(self, self.config).run(),	0,	"<StockItem>",	gtk.STOCK_PREFERENCES),

			("/_View",		None,			None,					None,							0,	"<Branch>"),
			("/View/_Toolbar",	None,			"Toggle display of the toolbar",	None,							0,	"<CheckItem>"),
			("/View/_Statusbar",	None,			"Toggle display of the statusbar",	None,							0,	"<CheckItem>"),
			("/View/sep1",		None,			None,					None,							0,	"<Separator>"),
			("/View/Show _Passwords",	"<Control>P",	"Show passwords",			None,							0,	"<CheckItem>"),

			("/_Help",		None,			None,					None,							0,	"<Branch>"),
			("/Help/_Homepage",	None,			"Visit the Revelation homepage",	lambda w,d: gnome.url_show(revelation.URL),		0,	"<StockItem>", gtk.STOCK_HOME),
			("/Help/_About",	None,			"Show info about this application",	lambda w,d: revelation.dialog.About(self).run(),	0,	"<StockItem>", "gnome-stock-about")
		)

		self.create_menu(menuitems)


	def __init_states(self):
		"Sets the initial application state"

		self.set_default_size(self.config.get("view/window-width"), self.config.get("view/window-height"))
		self.tree.select(None)
		self.dataview.display_info()

		self.if_menu.get_widget("<main>/Edit/Find Next").set_sensitive(gtk.FALSE)
		self.if_menu.get_widget("<main>/Edit/Find Previous").set_sensitive(gtk.FALSE)
		self.if_menu.get_widget("<main>/Edit/Undo").set_sensitive(gtk.FALSE)
		self.if_menu.get_widget("<main>/Edit/Redo").set_sensitive(gtk.FALSE)

		self.file		= None
		self.password		= None
		self.filepassword	= None

		self.show_all()

		self.config.bind_widget("view/passwords", self.if_menu.get_widget("<main>/View/Show Passwords"))
		self.config.bind_widget("view/statusbar", self.if_menu.get_widget("<main>/View/Statusbar"))
		self.config.bind_widget("view/toolbar", self.if_menu.get_widget("<main>/View/Toolbar"))

		self.config.notify_add("view/statusbar", self.__cb_config_statusbar)
		self.config.notify_add("view/toolbar", self.__cb_config_toolbar)


	def __init_toolbar(self):
		"Sets up the application toolbar"

		self.toolbar.button_new		= self.toolbar.append_stock(gtk.STOCK_NEW, "New file", lambda w,d: self.file_new())
		self.toolbar.button_open	= self.toolbar.append_stock(gtk.STOCK_OPEN, "Open file", lambda w,d: self.file_open())
		self.toolbar.button_save	= self.toolbar.append_stock(gtk.STOCK_SAVE, "Save file", lambda w,d: self.file_save(self.file, self.password))

		self.toolbar.append_space()

		self.toolbar.button_entry_add	= self.toolbar.append_stock(revelation.stock.STOCK_ADD, "Add a new entry", lambda w,d: self.entry_add())
		self.toolbar.button_entry_edit	= self.toolbar.append_stock(revelation.stock.STOCK_EDIT, "Edit the selected entry", lambda w,d: self.entry_edit())
		self.toolbar.button_entry_remove = self.toolbar.append_stock(revelation.stock.STOCK_REMOVE, "Remove the selected entry", lambda w,d: self.entry_remove())



	# config callbacks
	def __cb_config_statusbar(self, config, value, data):
		"Config callback for statusbar changes"

		if value == gtk.TRUE:
			self.statusbar.show()

		else:
			self.statusbar.hide()


	def __cb_config_toolbar(self, config, value, data):
		"Config callback for toolbar changes"

		if value == gtk.TRUE:
			self.toolbar.show()

		else:
			self.toolbar.hide()



	# callbacks for handling ui states
	def __cb_state_clipboard(self, widget, data = None):
		"Sets clipboard item sensitivity as appropriate"

		self.if_menu.get_widget("<main>/Edit/Paste").set_sensitive(self.clipboard.has_contents())


	def __cb_state_entry(self, widget, data = None):
		"Sets state for entry-dependent ui items"

		selcount = len(self.tree.get_selected())

		self.toolbar.button_entry_add.set_sensitive(selcount < 2)
		self.if_menu.get_widget("<main>/Edit/Add Entry...").set_sensitive(selcount < 2)
		self.if_menu.get_widget("<main>/Edit/Paste").set_sensitive(selcount < 2 and self.clipboard.has_contents())

		self.toolbar.button_entry_edit.set_sensitive(selcount == 1)
		self.if_menu.get_widget("<main>/Edit/Edit").set_sensitive(selcount == 1)

		self.toolbar.button_entry_remove.set_sensitive(selcount > 0)
		self.if_menu.get_widget("<main>/Edit/Remove").set_sensitive(selcount > 0)
		self.if_menu.get_widget("<main>/Edit/Cut").set_sensitive(selcount > 0)
		self.if_menu.get_widget("<main>/Edit/Copy").set_sensitive(selcount > 0)


	def __cb_state_file(self, widget, data = None):
		"Sets various states based on current file"

		self.data.changed = gtk.FALSE

		self.if_menu.get_widget("<main>/File/Revert").set_sensitive(self.file is not None)
		self.if_menu.get_widget("<main>/File/Lock...").set_sensitive(self.file is not None)

		if self.file is None:
			self.set_title("[New file]")
			self.password = self.filepassword = None

		else:
			self.set_title(os.path.basename(self.file))
			os.chdir(os.path.dirname(self.file))


	def __cb_state_find(self, widget, data = None):
		"Sets ui item states for find-related items"

		self.if_menu.get_widget("<main>/Edit/Find Next").set_sensitive(self.finder.string != "")
		self.if_menu.get_widget("<main>/Edit/Find Previous").set_sensitive(self.finder.string != "")


	def __cb_state_undo(self, widget, data = None):
		"Sets states for undo-related ui items"

		# update undo widgets
		widget = self.if_menu.get_widget("<main>/Edit/Undo")
		action = "_Undo"

		if self.undoqueue.can_undo():
			widget.get_children()[0].set_label(action + " " + self.undoqueue.get_action(revelation.data.UNDO).name)
			widget.set_sensitive(gtk.TRUE)

		else:
			widget.get_children()[0].set_label(action)
			widget.set_sensitive(gtk.FALSE)

		# update redo widgets
		widget = self.if_menu.get_widget("<main>/Edit/Redo")
		action = "_Redo"

		if self.undoqueue.can_redo():
			widget.get_children()[0].set_label(action + " " + self.undoqueue.get_action(revelation.data.REDO).name)
			widget.set_sensitive(gtk.TRUE)

		else:
			widget.get_children()[0].set_label(action)
			widget.set_sensitive(gtk.FALSE)



	# other, normal callbacks
	def __cb_doubleclick_tree(self, widget, iter):
		if iter is not None and self.data.get_entry(iter).type != revelation.entry.ENTRY_FOLDER:
			self.entry_edit()


	def __cb_entry_display(self, widget, data = None):
		"Displays the selected entry"

		self.dataview.display_entry(self.data.get_entry(self.tree.get_active()))


	def __cb_popup_tree(self, widget, data = None):
		"Displays a popup-menu for the treeview"

		if data.button != 3:
			return

		path = self.tree.get_path_at_pos(int(data.x), int(data.y))

		if path is None:
			self.tree.unselect_all()

		elif self.tree.selection.iter_is_selected(self.data.get_iter(path[0])) == gtk.FALSE:
			self.tree.set_cursor(path[0], path[1], gtk.FALSE)

		# create the popup menu
		iters = self.tree.get_selected()
		menuitems = []

		if len(iters) == 1:
			menuitems.append(("/Edit", None, "Edit the selected entry", lambda w,d: self.entry_edit(), 0, "<StockItem>", revelation.stock.STOCK_EDIT))

		if len(iters) > 0:
			menuitems.append(("/Remove", None, "Remove the selected entry", lambda w,d: self.entry_remove(), 0, "<StockItem>", revelation.stock.STOCK_REMOVE))

		if len(iters) < 2:
			menuitems.append(("/Add Entry...", None, "Create a new entry", lambda w,d: self.entry_add(), 0, "<StockItem>", revelation.stock.STOCK_ADD))


		clipboardmenu = []

		if len(iters) > 0:
			clipboardmenu.append(("/Cut", "", "Cut the selected entry to the clipboard", lambda w,d: self.clip_cut(), 0, "<StockItem>", gtk.STOCK_CUT))
			clipboardmenu.append(("/Copy", "", "Copy the selected entry to the keyboard", lambda w,d: self.clip_copy(), 0, "<StockItem>", gtk.STOCK_COPY))

		if len(iters) < 2 and self.clipboard.has_contents():
			clipboardmenu.append(("/Paste", "", "Paste entry from clipboard", lambda w,d: self.clip_paste(), 0, "<StockItem>", gtk.STOCK_PASTE))


		if len(clipboardmenu) > 0:
			menuitems.append(("/sep1", None, None, None, 0, "<Separator>"))
			menuitems.extend(clipboardmenu)


		self.popup(menuitems, int(data.x_root), int(data.y_root), data.button, data.get_time())

		return gtk.TRUE


	def __cb_quit(self, widget = None, data = None):
		"Quits the application"

		return gtk.TRUE ^ self.quit()



	# various private methods
	def __entry_find(self, parent, direction = revelation.data.SEARCH_NEXT):
		self.finder.folders = self.config.get("search/folders")
		self.finder.casesens = self.config.get("search/casesens")
		self.finder.namedesc = self.config.get("search/namedesc")

		match = self.finder.find(self.tree.get_active(), direction)

		if match is None:
			revelation.dialog.Error(parent, "No match found", "The string you searched for did not match any entries. Try using a different search-phrase.").run()
		else:
			self.tree.select(match)


	def __file_autosave(self):
		"Autosaves the current file, due to data modification"

		if self.file is None or self.password is None:
			return

		if not self.config.get("file/autosave"):
			return

		self.file_save(self.file, self.password)


	def __file_load(self, datafile):
		"Loads data from a file into an entrystore"

		try:
			if datafile.handler is None:
				datafile.detect_type()

			datafile.check_file()

			dialog = revelation.dialog.Password(
				self, "Enter file password",
				"The file '" + datafile.file + "' is encrypted. Please enter the file password to open it."
			)

			entrystore = None

			while 1:

				# load datafile, ask for password if needed
				try:
					if datafile.needs_password() and datafile.password is None:
						dialog.run()
						datafile.password = dialog.entry_password.get_text()

					entrystore = datafile.load()

				except revelation.datahandler.PasswordError:
					datafile.password = None
					revelation.dialog.Error(
						self, "Incorrect password",
						"The password you entered for the file'" + datafile.file + "' was not correct."
					).run()

				except:
					dialog.destroy()
					raise

				else:
					dialog.destroy()
					break

		except revelation.datahandler.FormatError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Invalid file format",
				"The file '" + datafile.file + "' is not a valid data file."
			).run()

		except revelation.entry.EntryError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Unknown data",
				"The file '" + datafile.file + "' contained unknown data. It may have been created by a future version of Revelation, try upgrading to a newer version."
			).run()

		except revelation.datahandler.VersionError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Unknown data version",
				"The file '" + datafile.file + "' has a future version number - upgrade Revelation to a more recent version to open it."
			).run()

		except revelation.io.DetectError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Filetype autodetection failed",
				"The format of the file '" + datafile.file + "' could not be detected automatically. It may still be possible to open the file, try specifying the file type manually."
			).run()

		except IOError:
			self.statusbar.set_status("Open failed")
			revelation.dialog.Error(
				self, "Unable to open file",
				"The file '" + datafile.file + "' could not be opened. Make sure that the file exists, and that you have the proper permissions to open it."
			).run()

		except revelation.CancelError:
			dialog.destroy()
			raise revelation.CancelError

		else:
			return entrystore



	def __file_save(self, datafile):
		"Saves data to a file"

		try:
			if datafile.file != self.file and revelation.io.file_exists(datafile.file):
				revelation.dialog.FileOverwrite(self, datafile.file).run()


			if not datafile.needs_password():
				revelation.dialog.FileExportInsecure(self).run()

			elif datafile.password is None:
				try:
					dialog = revelation.dialog.Password(
						self, "Enter file password",
						"Please enter a password which will be used to encrypt the file. You will need this password to open the file at a later time.",
						gtk.FALSE, gtk.TRUE
					)

					dialog.run()
					datafile.password = dialog.entry_new.get_text()
					dialog.destroy()

				except revelation.CancelError:
					dialog.destroy()
					raise


			datafile.save(self.data)


		except IOError:
			revelation.dialog.Error(self, "Unable to write to file", "The file '" + datafile.file + "' could not be opened for writing. Make sure that you have the proper permissions to write to it.").run()
			self.statusbar.set_status("Save failed")
			return gtk.FALSE

		else:
			return gtk.TRUE



	# public methods
	def change_password(self):
		"Changes the password of the current data file"

		try:
			dialog = revelation.dialog.Password(
				self, "Enter new password",
				"Enter a new password for the current data file. The file must be saved before the new password is applied.",
				self.password is not None, gtk.TRUE
			)

			while 1:
				dialog.run()

				if self.password is not None and dialog.entry_password.get_text() != self.password:
					revelation.dialog.Error(dialog, "Incorrect password", "The password you entered as the current file password is incorrect.").run()

				else:
					self.password = dialog.entry_new.get_text()
					self.data.changed = gtk.TRUE
					self.__file_autosave()
					self.statusbar.set_status("Password changed")
					break

		except revelation.CancelError:
			self.statusbar.set_status("Password change cancelled")

		dialog.destroy()


	def clip_copy(self):
		"Copies selected entries to the clipboard"

		iters = self.data.filter_parents(self.tree.get_selected())
		self.clipboard.copy(self.data, iters)


	def clip_cut(self):
		"Cuts selected entries to the clipboard"

		iters = self.data.filter_parents(self.tree.get_selected())
		self.undoqueue.add_action(revelation.data.UNDO_ACTION_CUT, iters)
		self.clipboard.cut(self.data, iters)
		self.tree.unselect_all()


	def clip_paste(self):
		"Pastes entries from the clipboard"

		if not self.clipboard.has_contents():
			return

		iters = self.clipboard.paste(self.data, self.tree.get_active())
		self.undoqueue.add_action(revelation.data.UNDO_ACTION_PASTE, iters)
		self.tree.select(iters[0])


	def entry_add(self):
		"Adds an entry"

		try:
			entry = revelation.dialog.EditEntry(self, "Add entry").run()
			iter = self.data.add_entry(self.tree.get_active(), entry)

			self.undoqueue.add_action(revelation.data.UNDO_ACTION_ADD, iter)
			self.__file_autosave()
			self.tree.select(iter)
			self.statusbar.set_status("Added entry '" + entry.name + "'")

		except revelation.CancelError:
			self.statusbar.set_status("Add entry cancelled")


	def entry_edit(self):
		"Edits an entry"

		iter = self.tree.get_active()

		if iter is None:
			return

		try:
			entry = self.data.get_entry(iter)
			dialog = revelation.dialog.EditEntry(self, "Edit entry", entry)

			if entry.type == revelation.entry.ENTRY_FOLDER and self.data.iter_n_children(iter) > 0:
				dialog.set_typechange_allowed(gtk.FALSE)

			newentry = dialog.run()
			self.data.update_entry(iter, newentry)
			self.undoqueue.add_action(revelation.data.UNDO_ACTION_EDIT, iter, entry)
			self.__file_autosave()
			self.tree.select(iter)
			self.statusbar.set_status("Updated entry '" + newentry.name + "'")

		except revelation.CancelError:
			self.statusbar.set_status("Update entry cancelled")


	def entry_find(self):
		"Searches for an entry"

		dialog = revelation.dialog.Find(self, self.config)
		dialog.entry_phrase.set_text(self.finder.string)
		dialog.dropdown.set_type(self.finder.type)

		while 1:
			response = dialog.run()
			self.finder.string = dialog.entry_phrase.get_text()
			self.finder.type = dialog.dropdown.get_type()

			if response == revelation.dialog.RESPONSE_NEXT:
				self.__entry_find(dialog, revelation.data.SEARCH_NEXT)

			elif response == revelation.dialog.RESPONSE_PREVIOUS:
				self.__entry_find(dialog, revelation.data.SEARCH_PREV)

			else:
				dialog.destroy()
				break


	def entry_remove(self):
		"Removes one or more entries"

		iters = self.tree.get_selected()

		if len(iters) == 0:
			return

		elif len(iters) == 1:
			entry = self.data.get_entry(iters[0])

			if entry.type == revelation.entry.ENTRY_FOLDER:
				pritext = "Really remove folder '" + entry.name + "'?"
				sectext = "By removing this folder you will also remove all accounts and folders it contains."

			else:
				pritext = "Really remove account '" + entry.name + "'?"
				sectext = "Please confirm that you wish to remove this account."

			statustext = "Removed entry '" + entry.name + "'"

		else:
			pritext = "Really remove the " + str(len(iters)) + " selected entries?"
			sectext = "By removing these entries you will also remove any entries they may contain."
			statustext = "Removed " + str(len(iters)) + " entries"


		if revelation.dialog.RemoveEntry(self, pritext, sectext).run() == gtk.TRUE:
			iters = self.data.filter_parents(iters)
			self.undoqueue.add_action(revelation.data.UNDO_ACTION_REMOVE, iters)

			for iter in iters:
				self.data.remove_entry(iter)

			self.__file_autosave()
			self.tree.unselect_all()
			self.statusbar.set_status(statustext)

		else:
			self.statusbar.set_status("Remove entry cancelled")


	def file_export(self):
		"Exports data to a foreign file format"

		try:
			file, handler = revelation.dialog.ExportFileSelector(self).run()
			datafile = revelation.io.DataFile(file, handler)
			self.__file_save(datafile)

		except revelation.CancelError:
			self.statusbar.set_status("Export cancelled")

		else:
			self.statusbar.set_status("Data exported to " + datafile.file)


	def file_import(self):
		"Imports data from a foreign file"

		try:
			file, handler = revelation.dialog.ImportFileSelector(self).run()
			datafile = revelation.io.DataFile(file, handler)
			entrystore = self.__file_load(datafile)

			if entrystore is None:
				return

		except revelation.CancelError:
			self.statusbar.set_status("Import cancelled")

		else:
			iters = self.data.import_entrystore(entrystore)
			self.undoqueue.add_action(revelation.data.UNDO_ACTION_IMPORT, iters)
			self.__file_autosave()
			self.statusbar.set_status("Data imported from " + datafile.file)


	def file_lock(self):
		"Locks the current data file"

		if self.password is None:
			return

		iter = self.tree.get_active()
		self.tree.set_model(None)
		self.dataview.clear()
		self.statusbar.set_status("File locked")

		dialog = revelation.dialog.Password(self, "Enter password to unlock file", "The current file has been locked. Please enter the file password to unlock it.")
		dialog.get_button(1).destroy()

		while 1:
			try:
				dialog.run()

				if dialog.entry_password.get_text() == self.password:
					break

				else:
					revelation.dialog.Error(dialog, "Incorrect password", "The password you entered was not correct. Please try again.").run()

			except revelation.CancelError:
				pass

		dialog.destroy()

		self.tree.set_model(self.data)
		self.tree.select(iter)
		self.statusbar.set_status("File unlocked")


	def file_new(self):
		"Opens a new file"

		if not self.save_changes("Save changes to current file?", "You have made changes which have not been saved. If you create a new file without saving, then these changes will be discarded."):
			self.statusbar.set_status("New file cancelled")
			return

		self.data.clear()
		self.undoqueue.clear()
		self.file = None
		self.statusbar.set_status("New file created")


	def file_open(self, file = None, password = None):
		"Opens a data file"

		try:
			if not self.save_changes("Save changes before opening?", "You have made changes which have not been saved. If you open another file without saving, then these changes will be discarded."):
				return

			if file is None:
				file = revelation.dialog.FileSelector(self, "Select file to open").run()

			datafile = revelation.io.DataFile(file, revelation.datahandler.Revelation, password)
			entrystore = self.__file_load(datafile)

			if entrystore is None:
				return

		except revelation.CancelError:
			self.statusbar.set_status("Open cancelled")

		else:
			self.data.clear()
			self.undoqueue.clear()
			self.data.import_entrystore(entrystore)

			self.file = datafile.file
			self.password = self.filepassword = datafile.password
			self.statusbar.set_status("Opened file " + datafile.file)


	def file_revert(self):
		"Reverts to the saved version of the file"

		if self.data.changed == gtk.TRUE and revelation.dialog.Hig(
			self, "Ignore unsaved changes?", "You have made changes which have not yet been saved. If you revert to the saved file then these changes will be lost.",
			gtk.STOCK_DIALOG_WARNING, [ [ gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL ], [ gtk.STOCK_REVERT_TO_SAVED, gtk.RESPONSE_OK ] ], 0
		).run() != gtk.RESPONSE_OK:
			return gtk.FALSE

		self.file_open(self.file, self.filepassword, gtk.TRUE)


	def file_save(self, file = None, password = None):
		"Saves a data file"

		try:
			if file is None:
				file = revelation.dialog.FileSelector(self, "Select file to save data to").run()

			datafile = revelation.io.DataFile(file, revelation.datahandler.Revelation, password)

			if self.__file_save(datafile) == gtk.TRUE:
				self.file = file
				self.password = self.filepassword = password
				self.statusbar.set_status("Data saved to file " + file)
				return gtk.TRUE

		except revelation.CancelError:
			self.statusbar.set_status("Save cancelled")
			return gtk.FALSE



	def save_changes(self, pritext, sectext):
		"Asks the user if she wants to save her changes"

		if self.data.changed == gtk.FALSE:
			return gtk.TRUE

		try:
			if revelation.dialog.SaveChanges(self, pritext, sectext).run() == gtk.TRUE and self.file_save(self.file, self.password) == gtk.FALSE:
				return gtk.FALSE

		except revelation.CancelError:
			return gtk.FALSE

		return gtk.TRUE


	def quit(self):
		"Quits the application"

		if not self.save_changes("Save changes before quitting?", "You have made changes which have not been saved. If you quit without saving, then these changes will be discarded."):
			self.statusbar.set_status("Quit cancelled")
			return gtk.FALSE

		width, height = self.get_size()
		self.config.set("view/window-width", width)
		self.config.set("view/window-height", height)
		self.config.set("view/pane-position", self.hpaned.get_position())

		gtk.mainquit()
		return gtk.TRUE


	def redo(self):
		"Redo the previously undone operation"

		if not self.undoqueue.can_redo():
			return

		action = self.undoqueue.get_action(revelation.data.REDO)
		iters = self.undoqueue.redo()

		if len(iters) > 0:
			self.tree.select(iters[0])
		else:
			self.tree.unselect_all()

		self.statusbar.set_status(action.name.capitalize() + " redone")


	def run(self, file = None):
		"Run the application"

		if file is not None:
			self.file_open(file)
		elif self.config.get("file/autoload"):
			self.file_open(self.config.get("file/autoload_file"))

		gtk.main()


	def undo(self):
		"Attempts to undo the previous operation"

		if not self.undoqueue.can_undo():
			return

		action = self.undoqueue.get_action()
		iters = self.undoqueue.undo()

		if len(iters) > 0:
			self.tree.select(iters[0])
		else:
			self.tree.unselect_all()

		self.statusbar.set_status(action.name.capitalize() + " undone")


gobject.signal_new("file-changed", Revelation, gobject.SIGNAL_ACTION, gobject.TYPE_BOOLEAN, ())



if __name__ == "__main__":
	file = None
	if len(sys.argv) > 1:
		file = os.path.abspath(sys.argv[1])

	Revelation().run(file)

