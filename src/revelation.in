#!/usr/bin/env python

#
# Revelation 0.4.4 - a password manager for GNOME 2
# http://oss.codepoet.no/revelation/
# $Id$
#
# Copyright (c) 2003-2005 Erik Grinaker
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

import gnome, gobject, gtk, gtk.gdk, os, pwd, sys

if "@pyexecdir@" not in sys.path:
	sys.path.insert(0, "@pyexecdir@")

from revelation import gnomemisc, config, data, datahandler, dialog, entry, io, ui, util


class Revelation(ui.App):
	"The Revelation application"

	def __init__(self):
		sys.excepthook = self.__cb_exception
		os.umask(0077)

		self.program = gnome.init(
			config.APPNAME, config.APPNAME,
			gnome.libgnome_module_info_get(), sys.argv, []
		)

		gnomemisc.gnome_authentication_manager_init()
		ui.App.__init__(self, config.APPNAME)

		self.connect("delete-event", self.__cb_quit)

		try:
			self.__init_facilities()
			self.__init_ui()
			self.__init_states()

		except IOError:
			dialog.Error(self, "Missing data files", "Some of Revelations system files could not be found, please reinstall Revelation.").run()
			sys.exit(1)

		except config.ConfigError:
			dialog.Error(self, "Missing configuration data", "Revelation could not find its configuration data, please reinstall Revelation.").run()
			sys.exit(1)

		except ui.DataError:
			dialog.Error(self, "Invalid data files", "Some of Revelations system files contain invalid data, please reinstall Revelation.").run()
			sys.exit(1)


	def __init_facilities(self):
		"Sets up various facilities"

		self.clipboard		= data.Clipboard()
		self.config		= config.Config()
		self.datafile		= io.DataFile(datahandler.Revelation)
		self.entryclipboard	= data.EntryClipboard()
		self.entrystore		= data.EntryStore()
		self.entrysearch	= data.EntrySearch(self.entrystore)
		self.items		= ui.ItemFactory(self)
		self.locktimer		= data.Timer()
		self.sessionclient	= gnome.ui.master_client()
		self.undoqueue		= data.UndoQueue()

		self.datafile.connect("changed", lambda w,f: self.__state_file(f))
		self.datafile.connect("content-changed", self.__cb_file_content_changed)
		self.entryclipboard.connect("content-toggled", lambda w,d: self.__state_clipboard(d))
		self.locktimer.connect("ring", self.__cb_file_autolock)
		self.undoqueue.connect("changed", lambda w: self.__state_undo(self.undoqueue.get_undo_action(), self.undoqueue.get_redo_action()))

		# workaround for gnome-python 2.9.x api bug
		gobject.GObject.connect(self.sessionclient, "die", lambda w: self.quit())
		gobject.GObject.connect(self.sessionclient, "save-yourself", self.__cb_session_save)

		# check if configuration is updated, install schema if not
		if self.__check_config() == False:

			if config.install_schema("%s/revelation.schemas" % config.DIR_GCONFSCHEMAS) == False:
				raise config.ConfigError

			if self.__check_config() == False:
				raise config.ConfigError


		self.config.monitor("search/folders",		lambda k,v,d: setattr(self.entrysearch, "folders", v))
		self.config.monitor("search/namedesc",		lambda k,v,d: setattr(self.entrysearch, "namedesconly", v))
		self.config.monitor("search/casesens",		lambda k,v,d: setattr(self.entrysearch, "casesensitive", v))
		self.config.monitor("file/autolock_timeout",	lambda k,v,d: self.locktimer.start(v * 60))

		dialog.EVENT_FILTER = self.__cb_event_filter


	def __init_states(self):
		"Sets the initial application state"

		# set window states
		self.set_default_size(
			self.config.get("view/window-width"),
			self.config.get("view/window-height")
		)

		self.move(
			self.config.get("view/window-position-x"),
			self.config.get("view/window-position-y")
		)

		self.hpaned.set_position(
			self.config.get("view/pane-position")
		)

		# bind ui widgets to config keys
		bind = {
			"view/passwords"	: "/menubar/menu-view/view-passwords",
			"view/searchbar"	: "/menubar/menu-view/view-searchbar",
			"view/statusbar"	: "/menubar/menu-view/view-statusbar",
			"view/toolbar"		: "/menubar/menu-view/view-toolbar"
		}

		for key, path in bind.items():
			ui.config_bind(self.config, key, self.uimanager.get_widget(path))


		self.entryview.display_info()
		self.show_all()

		self.window.add_filter(self.__cb_event_filter)


		# set some variables
		self.entrysearch.string	= ""
		self.entrysearch.type	= None

		# set ui widget states
		self.__state_clipboard(self.entryclipboard.has_contents())
		self.__state_entry([])
		self.__state_file(None)
		self.__state_find(self.entrysearch.string)
		self.__state_undo(None, None)

		# set states from config
		self.config.monitor("view/searchbar", self.__cb_config_toolbar, self.searchbar)
		self.config.monitor("view/statusbar", self.__cb_config_toolbar, self.statusbar)
		self.config.monitor("view/toolbar", self.__cb_config_toolbar, self.toolbar)

		# give focus to searchbar entry if shown
		if self.searchbar.get_property("visible") == True:
			self.searchbar.entry.grab_focus()


	def __init_ui(self):
		"Sets up the UI"

		# set window icons
		pixbufs = [ self.items.load_icon("revelation", size) for size in ( 48, 32, 24, 16) ]
		pixbufs = [ pixbuf for pixbuf in pixbufs if pixbuf != None ]

		if len(pixbufs) > 0:
			gtk.window_set_default_icon_list(*pixbufs)

		# load UI definitions
		self.uimanager.add_actions_from_file(config.DIR_UI + "/actions.xml")
		self.uimanager.add_ui_from_file(config.DIR_UI + "/menubar.xml")
		self.uimanager.add_ui_from_file(config.DIR_UI + "/popup-tree.xml")
		self.uimanager.add_ui_from_file(config.DIR_UI + "/toolbar.xml")

		# set up callbacks for actions
		callbacks = {
			"clip-chain"		: lambda w: self.clip_chain(self.entrystore.get_entry(self.tree.get_active())),
			"clip-copy"		: self.__cb_clip_copy,
			"clip-cut"		: self.__cb_clip_cut,
			"clip-paste"		: self.__cb_clip_paste,
			"entry-add"		: lambda w: self.entry_add(None, self.tree.get_active()),
			"entry-edit"		: lambda w: self.entry_edit(self.tree.get_active()),
			"entry-folder"		: lambda w: self.entry_folder(None, self.tree.get_active()),
			"entry-goto"		: lambda w: self.entry_goto(self.tree.get_selected()),
			"entry-remove"		: lambda w: self.entry_remove(self.tree.get_selected()),
			"file-change-password"	: lambda w: self.file_change_password(),
			"file-close"		: self.__cb_quit,
			"file-export"		: lambda w: self.file_export(),
			"file-import"		: lambda w: self.file_import(),
			"file-lock"		: lambda w: self.file_lock(),
			"file-new"		: lambda w: self.file_new(),
			"file-open"		: lambda w: self.file_open(),
			"file-save"		: lambda w: self.file_save(self.datafile.get_file(), self.datafile.get_password()),
			"file-save-as"		: lambda w: self.file_save(None, None),
			"find"			: lambda w: self.entry_find(),
			"find-next"		: lambda w: self.__entry_find(self, self.entrysearch.string, self.entrysearch.type, data.SEARCH_NEXT),
			"find-previous"		: lambda w: self.__entry_find(self, self.entrysearch.string, self.entrysearch.type, data.SEARCH_PREVIOUS),
			"help-about"		: lambda w: self.about(),
			"help-homepage"		: lambda w: gnome.url_show(config.URL),
			"prefs"			: lambda w: self.prefs(),
			"pwchecker"		: lambda w: self.pwcheck(),
			"pwgenerator"		: lambda w: self.pwgen(),
			"quit"			: self.__cb_quit,
			"redo"			: lambda w: self.redo(),
			"select-all"		: lambda w: self.tree.select_all(),
			"select-none"		: lambda w: self.tree.unselect_all(),
			"undo"			: lambda w: self.undo()
		}

		for id, callback in callbacks.items():
			action = self.uimanager.get_action(id)
			action.connect("activate", callback)

		# set up toolbar and menus
		self.set_menus(self.uimanager.get_widget("/menubar"))

		self.toolbar = self.uimanager.get_widget("/toolbar")
		self.set_toolbar(self.toolbar)

		try:
			detachable = self.config.get("/desktop/gnome/interface/toolbar_detachable")

		except config.ConfigError:
			detachable = False

		self.searchbar = ui.Searchbar()
		self.add_toolbar(self.searchbar, "searchbar", 2, detachable)

		# set up main application widgets
		self.tree = ui.EntryTree(self.entrystore)
		self.scrolledwindow = ui.ScrolledWindow(self.tree)

		self.entryview = ui.EntryView(self.config, self.clipboard)
		alignment = gtk.Alignment(0.5, 0.4, 0, 0)
		alignment.add(self.entryview)

		self.hpaned = ui.HPaned(self.scrolledwindow, alignment)
		self.set_contents(self.hpaned)

		# set up drag-and-drop
		self.drag_dest_set(gtk.DEST_DEFAULT_ALL, ( ( "text/uri-list", 0, 0 ), ), gtk.gdk.ACTION_COPY | gtk.gdk.ACTION_MOVE | gtk.gdk.ACTION_LINK )
		self.connect("drag_data_received", self.__cb_drag_dest)

		self.tree.enable_model_drag_source(gtk.gdk.BUTTON1_MASK, ( ( "revelation/treerow", gtk.TARGET_SAME_APP | gtk.TARGET_SAME_WIDGET, 0), ), gtk.gdk.ACTION_MOVE)
		self.tree.enable_model_drag_dest(( ( "revelation/treerow", gtk.TARGET_SAME_APP | gtk.TARGET_SAME_WIDGET, 0), ), gtk.gdk.ACTION_MOVE)
		self.tree.connect("drag_data_received", self.__cb_tree_drag_received)

		# set up callbacks
		self.searchbar.button.connect("clicked", lambda w: self.__entry_find(self, self.searchbar.entry.get_text(), None))

		self.tree.connect("popup", lambda w,d: self.popup(self.uimanager.get_widget("/popup-tree"), d.button, d.time))
		self.tree.connect("doubleclick", self.__cb_tree_doubleclick)
		self.tree.connect("key-press-event", self.__cb_tree_keypress)
		self.tree.selection.connect("changed", lambda w: self.entryview.display_entry(self.entrystore.get_entry(self.tree.get_active())))
		self.tree.selection.connect("changed", lambda w: self.__state_entry(self.tree.get_selected()))

		# dialog checkers
		self.dialog_about	= None
		self.dialog_find	= None
		self.dialog_prefs	= None
		self.dialog_pwcheck	= None
		self.dialog_pwgen	= None



	##### STATE HANDLERS #####

	def __save_state(self):
		"Saves the current application state"

		width, height = self.get_size()
		self.config.set("view/window-width", width)
		self.config.set("view/window-height", height)

		x, y = self.get_position()
		self.config.set("view/window-position-x", x)
		self.config.set("view/window-position-y", y)

		self.config.set("view/pane-position", self.hpaned.get_position())


	def __state_clipboard(self, has_contents):
		"Sets states based on the clipboard contents"

		self.uimanager.get_action("clip-paste").set_property("sensitive", has_contents)


	def __state_entry(self, iters):
		"Sets states for entry-dependant ui items"

		# widget sensitivity based on number of entries
		self.uimanager.get_action_group("entry-multiple").set_sensitive(len(iters) > 0)
		self.uimanager.get_action_group("entry-single").set_sensitive(len(iters) == 1)
		self.uimanager.get_action_group("entry-optional").set_sensitive(len(iters) < 2)


		# copy password sensitivity
		s = False

		for iter in iters:
			e = self.entrystore.get_entry(iter)

			for f in e.fields:
				if f.datatype == entry.DATATYPE_PASSWORD and f.value != "":
					s = True

		self.uimanager.get_action("clip-chain").set_property("sensitive", s)


		# goto sensitivity
		try:
			for iter in iters:
				e = self.entrystore.get_entry(iter)

				if self.config.get("launcher/%s" % e.id) not in ( "", None ):
					s = True
					break

			else:
				s = False

		except config.ConfigError:
			s = False

		self.uimanager.get_action_group("entry-goto").set_sensitive(s)


	def __state_file(self, file):
		"Sets states based on file"

		self.uimanager.get_action_group("file-exists").set_sensitive(file is not None)

		if file is not None:
			self.set_title(os.path.basename(file))

			if io.file_is_local(file):
				os.chdir(os.path.dirname(file))

		else:
			self.set_title("[New file]")


	def __state_find(self, string):
		"Sets states based on the current search string"

		self.uimanager.get_action_group("find").set_sensitive(string != "")


	def __state_undo(self, undoaction, redoaction):
		"Sets states based on undoqueue actions"

		if undoaction is None:
			s, l = False, "_Undo"

		else:
			s, l = True, "_Undo %s" % undoaction[1].lower()

		action = self.uimanager.get_action("undo")
		action.set_property("sensitive", s)
		action.set_property("label", l)


		if redoaction is None:
			s, l = False, "_Redo"

		else:
			s, l = True, "_Redo %s" % redoaction[1].lower()

		action = self.uimanager.get_action("redo")
		action.set_property("sensitive", s)
		action.set_property("label", l)




	##### MISC CALLBACKS #####

	def __cb_clip_copy(self, widget, data = None):
		"Handles copying to the clipboard"

		focuswidget = self.get_focus()

		if focuswidget is self.tree:
			self.clip_copy(self.tree.get_selected())

		elif isinstance(focuswidget, gtk.Label) or isinstance(focuswidget, gtk.Entry):
			focuswidget.emit("copy-clipboard")


	def __cb_clip_cut(self, widget, data = None):
		"Handles cutting to clipboard"

		focuswidget = self.get_focus()

		if focuswidget is self.tree:
			self.clip_cut(self.tree.get_selected())

		elif isinstance(focuswidget, gtk.Entry):
			focuswidget.emit("cut-clipboard")


	def __cb_clip_paste(self, widget, data = None):
		"Handles pasting from clipboard"

		focuswidget = self.get_focus()

		if focuswidget is self.tree:
			self.clip_paste(self.entryclipboard.get(), self.tree.get_active())

		elif isinstance(focuswidget, gtk.Entry):
			focuswidget.emit("paste-clipboard")


	def __cb_drag_dest(self, widget, context, x, y, seldata, info, time, userdata = None):
		"Handles file drops"

		if seldata.data is None:
			return

		files = [ file.strip() for file in seldata.data.split("\n") if file.strip() != "" ]

		if len(files) > 0:
			self.file_open(files[0])


	def __cb_event_filter(self, event):
		"Event filter for gdk window"

		self.locktimer.reset()
		return gtk.gdk.FILTER_CONTINUE


	def __cb_exception(self, type, value, trace):
		"Callback for unhandled exceptions"

		if type == KeyboardInterrupt:
			sys.exit(1)

		traceback = util.trace_exception(type, value, trace)
		sys.stderr.write(traceback)

		if dialog.Exception(self, traceback).run() == True:
			gtk.main()

		else:
			sys.exit(1)


	def __cb_file_content_changed(self, widget, file):
		"Callback for changed file"

		try:
			if dialog.FileChanged(self, file).run() == True:
				self.file_open(self.datafile.get_file(), self.datafile.get_password())

		except dialog.CancelError:
			self.statusbar.set_status("Open cancelled")


	def __cb_file_autolock(self, widget, data = None):
		"Callback for locking the file"

		if self.config.get("file/autolock") == True:
			self.file_lock()


	def __cb_quit(self, widget, data = None):
		"Callback for quit"

		if self.quit() == False:
			return True

		else:
			return False


	def __cb_session_save(self, widget, phase, what, end, interaction, fast, data = None):
		"Handles session saves"

		self.sessionclient.set_current_directory(os.getcwd())
		self.sessionclient.set_clone_command(sys.argv[0])

		if self.datafile.get_file() == None:
			self.sessionclient.set_restart_command(1, [ sys.argv[0] ])

		else:
			self.sessionclient.set_restart_command(2, [ sys.argv[0], self.datafile.get_file() ] )

		self.__save_state()

		return True


	def __cb_tree_doubleclick(self, widget, data = None):
		"Handles doubleclicks on the tree"

		if self.config.get("behavior/doubleclick") == "edit":
			self.entry_edit(self.tree.get_active())

		elif self.config.get("behavior/doubleclick") == "copy":
			self.clip_chain(self.entrystore.get_entry(self.tree.get_active()))

		else:
			self.entry_goto((self.tree.get_active(),))


	def __cb_tree_drag_received(self, tree, context, x, y, seldata, info, time):
		"Callback for drag drops on the treeview"

		# get source and destination data
		sourceiters = self.entrystore.filter_parents(self.tree.get_selected())
		destrow = self.tree.get_dest_row_at_pos(x, y)

		if destrow is None:
			destpath = ( self.entrystore.iter_n_children(None) - 1, )
			pos = gtk.TREE_VIEW_DROP_AFTER

		else:
			destpath, pos = destrow

		destiter = self.entrystore.get_iter(destpath)
		destpath = self.entrystore.get_path(destiter)

		# avoid drops to current iter or descentants
		for sourceiter in sourceiters:
			sourcepath = self.entrystore.get_path(sourceiter)

			if self.entrystore.is_ancestor(sourceiter, destiter) == True or sourcepath == destpath:
				context.finish(False, False, time)
				return

			elif pos == gtk.TREE_VIEW_DROP_BEFORE and sourcepath[:-1] == destpath[:-1] and sourcepath[-1] == destpath[-1] - 1:
				context.finish(False, False, time)
				return

			elif pos == gtk.TREE_VIEW_DROP_AFTER and sourcepath[:-1] == destpath[:-1] and sourcepath[-1] == destpath[-1] + 1:
				context.finish(False, False, time)
				return


		# move the entries
		if pos in ( gtk.TREE_VIEW_DROP_INTO_OR_BEFORE, gtk.TREE_VIEW_DROP_INTO_OR_AFTER):
			parent = destiter
			sibling = None

		elif pos == gtk.TREE_VIEW_DROP_BEFORE:
			parent = self.entrystore.iter_parent(destiter)
			sibling = destiter

		elif pos == gtk.TREE_VIEW_DROP_AFTER:
			parent = self.entrystore.iter_parent(destiter)

			sibpath = list(destpath)
			sibpath[-1] += 1
			sibling = self.entrystore.get_iter(sibpath)

		self.entry_move(sourceiters, parent, sibling)
		context.finish(True, True, time)


	def __cb_tree_keypress(self, widget, data = None):
		"Handles key presses for the tree"

		# return
		if data.keyval == 65293:
			self.entry_edit(self.tree.get_active())

		# insert
		elif data.keyval == 65379:
			self.entry_add(None, self.tree.get_active())

		# delete
		elif data.keyval == 65535:
			self.entry_remove(self.tree.get_selected())



	##### CONFIG CALLBACKS #####

	def __cb_config_toolbar(self, config, value, toolbar):
		"Config callback for showing toolbars"

		if value == True:
			toolbar.show()

		else:
			toolbar.hide()



	#### UNDO / REDO CALLBACKS #####

	def __cb_redo_add(self, name, actiondata):
		"Redoes an add action"

		path, e = actiondata
		parent = self.entrystore.get_iter(path[:-1])
		sibling = self.entrystore.get_iter(path)

		iter = self.entrystore.add_entry(e, parent, sibling)
		self.tree.select(iter)


	def __cb_redo_edit(self, name, actiondata):
		"Redoes an edit action"

		path, preentry, postentry = actiondata
		iter = self.entrystore.get_iter(path)

		self.entrystore.update_entry(iter, postentry)
		self.tree.select(iter)


	def __cb_redo_import(self, name, actiondata):
		"Redoes an import action"

		paths, entrystore = actiondata
		self.entrystore.import_entry(entrystore, None)


	def __cb_redo_move(self, name, actiondata):
		"Redoes a move action"

		newiters = []

		for prepath, postpath in actiondata:
			prepath, postpath = list(prepath), list(postpath)

			# adjust path if necessary
			if prepath[:-1] == postpath[:-1]:
				if prepath[-1] <= postpath[len(prepath) - 1]:
					postpath[len(prepath) - 1] += 1

			newiter = self.entrystore.move_entry(
				self.entrystore.get_iter(prepath),
				self.entrystore.get_iter(postpath[:-1]),
				self.entrystore.get_iter(postpath)
			)

			newiters.append(newiter)

		if len(newiters) > 0:
			self.tree.select(newiters[0])


	def __cb_redo_paste(self, name, actiondata):
		"Redoes a paste action"

		entrystore, parentpath, paths = actiondata
		iters = self.entrystore.import_entry(entrystore, None, self.entrystore.get_iter(parentpath))

		if len(iters) > 0:
			self.tree.select(iters[0])


	def __cb_redo_remove(self, name, actiondata):
		"Redoes a remove action"

		iters = []
		for path, entrystore in actiondata:
			iters.append(self.entrystore.get_iter(path))

		for iter in iters:
			self.entrystore.remove_entry(iter)

		self.tree.unselect_all()


	def __cb_undo_add(self, name, actiondata):
		"Undoes an add action"

		path, e = actiondata

		self.entrystore.remove_entry(self.entrystore.get_iter(path))
		self.tree.unselect_all()


	def __cb_undo_edit(self, name, actiondata):
		"Undoes an edit action"

		path, preentry, postentry = actiondata
		iter = self.entrystore.get_iter(path)

		self.entrystore.update_entry(iter, preentry)
		self.tree.select(iter)


	def __cb_undo_import(self, name, actiondata):
		"Undoes an import action"

		paths, entrystore = actiondata
		iters = [ self.entrystore.get_iter(path) for path in paths ]

		for iter in iters:
			self.entrystore.remove_entry(iter)

		self.tree.unselect_all()


	def __cb_undo_move(self, name, actiondata):
		"Undoes a move action"

		actiondata = actiondata[:]
		actiondata.reverse()

		newiters = []

		for prepath, postpath in actiondata:
			prepath, postpath = list(prepath), list(postpath)

			# adjust path if necessary
			if postpath[:-1] == prepath[:len(postpath) - 1]:
				if postpath[-1] <= prepath[len(postpath) - 1]:
					prepath[len(postpath) - 1] += 1

			newiter = self.entrystore.move_entry(
				self.entrystore.get_iter(postpath),
				self.entrystore.get_iter(prepath[:-1]),
				self.entrystore.get_iter(prepath)
			)

			newiters.append(newiter)

		if len(newiters) > 0:
			self.tree.select(newiters[-1])


	def __cb_undo_paste(self, name, actiondata):
		"Undoes a paste action"

		entrystore, parentpath, paths = actiondata
		iters = [ self.entrystore.get_iter(path) for path in paths ]

		for iter in iters:
			self.entrystore.remove_entry(iter)

		self.tree.unselect_all()


	def __cb_undo_remove(self, name, actiondata):
		"Undoes a remove action"

		iters = []
		for path, entrystore in actiondata:
			parent = self.entrystore.get_iter(path[:-1])
			sibling = self.entrystore.get_iter(path)

			iter = self.entrystore.import_entry(entrystore, entrystore.iter_nth_child(None, 0), parent, sibling)
			iters.append(iter)

		self.tree.select(iters[0])



	##### PRIVATE METHODS #####

	def __check_config(self):
		"Checks if the configuration is correct"

		try:
			self.config.get("launcher/website")
			self.config.get("view/searchbar")
			self.config.get("clipboard/chain_username")
			self.config.get("behavior/doubleclick")

			return True

		except config.ConfigError:
			return False


	def __entry_find(self, parent, string, entrytype, direction = data.SEARCH_NEXT):
		"Searches for an entry"

		match = self.entrysearch.find(string, entrytype, self.tree.get_active(), direction)

		self.entrysearch.string	= string
		self.entrysearch.type	= entrytype

		self.__state_find(string)

		if match is not None:
			self.tree.select(match)

		else:
			dialog.Error(parent, "No match found", "The string you searched for did not match any entries. Try searching for a different phrase.").run()


	def __file_autosave(self):
		"Autosaves the current file if needed"

		if self.datafile.get_file() is None or self.datafile.get_password() is None:
			return

		if self.config.get("file/autosave") == False:
			return

		self.__file_save(self.datafile.get_file(), self.datafile.get_password())
		self.entrystore.changed = False


	def __file_load(self, file, password, datafile = None):
		"Loads data from a data file into an entrystore"

		try:
			if datafile is None:
				datafile = self.datafile

			while 1:
				try:
					return datafile.load(file, password, lambda: dialog.PasswordOpen(self, os.path.basename(file)).run())

				except datahandler.PasswordError:
					dialog.Error(self, "Incorrect password", "The password you entered for the file'%s' was not correct." % file).run()

		except datahandler.FormatError:
			self.statusbar.set_status("Open failed")
			dialog.Error(self, "Invalid file format", "The file '%s' contains invalid data." % file).run()

		except ( datahandler.DataError, entry.EntryTypeError, entry.EntryFieldError ):
			self.statusbar.set_status("Open failed")
			dialog.Error(self, "Unknown data", "The file '%s' contains unknown data. It may have been created by a more recent version of Revelation.." % file).run()

		except datahandler.VersionError:
			self.statusbar.set_status("Open failed")
			dialog.Error(self, "Unknown data version", "The file '%s' has a future version number, please upgrade Revelation to open it." % file).run()

		except datahandler.DetectError:
			self.statusbar.set_status("Open failed")
			dialog.Error(self, "Unable to detect filetype", "The file type of the file '%s' could not be automatically detected. Try specifying the file type manually." % file).run()

		except IOError:
			self.statusbar.set_status("Open failed")
			dialog.Error(self, "Unable to open file", "The file '%s' could not be opened. Make sure that the file exists, and that you have permissions to open it." % file).run()


	def __file_save(self, file, password, datafile = None):
		"Saves data to a file"

		try:
			if datafile is None:
				datafile = self.datafile

			if io.file_normpath(str(datafile)) != io.file_normpath(file) and io.file_exists(file):
				dialog.FileOverwrite(self, file).run()

			if datafile.get_handler().encryption == True:
				if password is None:
					password = dialog.PasswordSave(self, file).run()

			else:
				dialog.FileSaveInsecure(self).run()

			datafile.save(self.entrystore, file, password)

		except IOError:
			dialog.Error(self, "Unable to write to file", "The file '%s' could not be opened for writing. Make sure that you have the proper permissions to write to it." % file).run()
			self.statusbar.set_status("Save failed")


	def __get_common_usernames(self, e = None):
		"Returns a list of possibly relevant usernames"

		list = []

		if e is not None and e.has_field(entry.UsernameField):
			list.append(e[entry.UsernameField])

		list.append(pwd.getpwuid(os.getuid())[0])
		list.extend(self.entrystore.get_popular_values(entry.UsernameField, 3))

		list = {}.fromkeys(list).keys()
		list.sort()

		return list


	def __save_changes(self, d):
		"Asks the user if she wants to save her changes"

		if self.entrystore.changed == True and d(self).run() == True:
			if self.file_save(self.datafile.get_file(), self.datafile.get_password()) == False:
				raise dialog.CancelError



	##### PUBLIC METHODS #####

	def about(self):
		"Displays the about dialog"

		if self.dialog_about != None:
			self.dialog_about.present()

		else:
			self.dialog_about = dialog.About(self)
			self.dialog_about.connect("destroy", lambda w: setattr(self, "dialog_about", None))

			self.dialog_about.run()


	def clip_chain(self, e):
		"Copies all passwords from an entry as a chain"

		if e == None:
			return

		secrets = [ field.value for field in e.fields if field.datatype == entry.DATATYPE_PASSWORD and field.value != "" ]

		if self.config.get("clipboard/chain_username") == True and len(secrets) > 0 and e.has_field(entry.UsernameField) and e[entry.UsernameField] != "":
			secrets.insert(0, e[entry.UsernameField])

		if len(secrets) == 0:
			self.statusbar.set_status("Entry has no password to copy")

		else:
			self.clipboard.set(secrets, True)
			self.statusbar.set_status("Password copied to clipboard")


	def clip_copy(self, iters):
		"Copies entries to the clipboard"

		self.entryclipboard.set(self.entrystore, iters)
		self.statusbar.set_status("Entries copied")


	def clip_cut(self, iters):
		"Cuts entries to the clipboard"

		iters = self.entrystore.filter_parents(iters)
		self.entryclipboard.set(self.entrystore, iters)

		# store undo data (need paths)
		undoactions = []
		for iter in iters:
			undostore = data.EntryStore()
			undostore.import_entry(self.entrystore, iter)
			path = self.entrystore.get_path(iter)
			undoactions.append( ( path, undostore ) )

		# remove data
		for iter in iters:
			self.entrystore.remove_entry(iter)

		self.undoqueue.add_action(
			"Cut entries", self.__cb_undo_remove, self.__cb_redo_remove,
			undoactions
		)

		self.__file_autosave()

		self.tree.unselect_all()
		self.statusbar.set_status("Entries cut")


	def clip_paste(self, entrystore, parent):
		"Pastes entries from the clipboard"

		if entrystore == None:
			return

		parent = self.tree.get_active()
		iters = self.entrystore.import_entry(entrystore, None, parent)

		paths = [ self.entrystore.get_path(iter) for iter in iters ]

		self.undoqueue.add_action(
			"Paste entries", self.__cb_undo_paste, self.__cb_redo_paste,
			( entrystore, self.entrystore.get_path(parent), paths )
		)

		if len(iters) > 0:
			self.tree.select(iters[0])

		self.statusbar.set_status("Entries pasted")


	def entry_add(self, e = None, parent = None, sibling = None):
		"Adds an entry"

		try:
			if e == None:
				d = dialog.EntryEdit(self, "Add Entry", None, self.config, self.clipboard)
				d.set_fieldwidget_data(entry.UsernameField, self.__get_common_usernames())
				e = d.run()

			iter = self.entrystore.add_entry(e, parent, sibling)

			self.undoqueue.add_action(
				"Add entry", self.__cb_undo_add, self.__cb_redo_add,
				( self.entrystore.get_path(iter), e.copy() )
			)

			self.__file_autosave()
			self.tree.select(iter)
			self.statusbar.set_status("Entry added")

		except dialog.CancelError:
			self.statusbar.set_status("Add entry cancelled")


	def entry_edit(self, iter):
		"Edits an entry"

		try:
			if iter == None:
				return

			e = self.entrystore.get_entry(iter)

			if type(e) == entry.FolderEntry:
				d = dialog.FolderEdit(self, "Edit Folder", e)

			else:
				d = dialog.EntryEdit(self, "Edit Entry", e, self.config, self.clipboard)
				d.set_fieldwidget_data(entry.UsernameField, self.__get_common_usernames(e))


			n = d.run()
			self.entrystore.update_entry(iter, n)
			self.tree.select(iter)

			self.undoqueue.add_action(
				"Update entry", self.__cb_undo_edit, self.__cb_redo_edit,
				( self.entrystore.get_path(iter), e.copy(), n.copy() )
			)

			self.__file_autosave()
			self.statusbar.set_status("Entry updated")

		except dialog.CancelError:
			self.statusbar.set_status("Edit entry cancelled")


	def entry_find(self):
		"Searches for an entry"

		if self.dialog_find != None:
			self.dialog_find.present()
			return


		def cb_response(widget, response):
			string = widget.entry_string.get_text()
			entrytype = widget.dropdown.get_active_type()

			if response == dialog.RESPONSE_NEXT:
				self.__entry_find(widget, string, entrytype, data.SEARCH_NEXT)
				widget.entry_string.grab_focus()

			elif response == dialog.RESPONSE_PREVIOUS:
				self.__entry_find(widget, string, entrytype, data.SEARCH_PREVIOUS)
				widget.entry_string.grab_focus()

			else:
				widget.destroy()


		self.dialog_find = dialog.Find(self, self.config)
		self.dialog_find.entry_string.set_text(self.entrysearch.string)
		self.dialog_find.dropdown.set_active_type(self.entrysearch.type)
		self.dialog_find.connect("destroy", lambda w: setattr(self, "dialog_find", None))
		self.dialog_find.connect("response", cb_response)
		self.dialog_find.run()


	def entry_folder(self, e = None, parent = None, sibling = None):
		"Adds a folder"

		try:
			if e == None:
				e = dialog.FolderEdit(self, "Add Folder").run()

			iter = self.entrystore.add_entry(e, parent, sibling)

			self.undoqueue.add_action(
				"Add folder", self.__cb_undo_add, self.__cb_redo_add,
				( self.entrystore.get_path(iter), e.copy() )
			)

			self.__file_autosave()
			self.tree.select(iter)
			self.statusbar.set_status("Folder added")

		except dialog.CancelError:
			self.statusbar.set_status("Add folder cancelled")


	def entry_goto(self, iters):
		"Goes to an entry"

		for iter in iters:
			try:

				# get goto data for entry
				e = self.entrystore.get_entry(iter)
				command = self.config.get("launcher/%s" % e.id)

				if command in ( "", None ):
					self.statusbar.set_status("No goto command found for " + e.typename + " entries")
					return

				subst = {}
				for field in e.fields:
					subst[field.symbol] = field.value

				# copy passwords to clipboard
				chain = []

				for field in e.fields:
					if field.datatype == entry.DATATYPE_PASSWORD and field.value != "":
						chain.append(field.value)

				if self.config.get("clipboard/chain_username") == True and len(chain) > 0 and e.has_field(entry.UsernameField) == True and e[entry.UsernameField] != "" and "%" + entry.UsernameField.symbol not in command:
					chain.insert(0, e[entry.UsernameField])

				self.clipboard.set(chain, True)

				# generate and run goto command
				command = util.parse_subst(command, subst)
				util.execute_child(command)

				self.statusbar.set_status("Entry opened")

			except ( util.SubstFormatError, config.ConfigError ):
				dialog.Error(self, "Invalid goto command format", "The goto command for '" + e.typename + "' entries is invalid, please correct this in the preferences.").run()

			except util.SubstValueError:
				dialog.Error(self, "Missing entry data", "The entry '" + e.name + "' does not have all the data required to go to it.").run()


	def entry_move(self, sourceiters, parent = None, sibling = None):
		"Moves a set of entries"

		if type(sourceiters) != list:
			sourceiters = [ sourceiters ]

		newiters = []
		undoactions = []

		for sourceiter in sourceiters:
			sourcepath = self.entrystore.get_path(sourceiter)
			newiter = self.entrystore.move_entry(sourceiter, parent, sibling)
			newpath = self.entrystore.get_path(newiter)

			undoactions.append( ( sourcepath, newpath ) )
			newiters.append(newiter)

		self.undoqueue.add_action(
			"Move entry", self.__cb_undo_move, self.__cb_redo_move,
			undoactions
		)

		if len(newiters) > 0:
			self.tree.select(newiters[0])

		self.__file_autosave()
		self.statusbar.set_status("Entries moved")


	def entry_remove(self, iters):
		"Removes the selected entries"

		try:
			if len(iters) == 0:
				return

			entries = [ self.entrystore.get_entry(iter) for iter in iters ]
			dialog.EntryRemove(self, entries).run()
			iters = self.entrystore.filter_parents(iters)

			# store undo data (need paths)
			undoactions = []
			for iter in iters:
				undostore = data.EntryStore()
				undostore.import_entry(self.entrystore, iter)
				path = self.entrystore.get_path(iter)
				undoactions.append( ( path, undostore ) )

			# remove data
			for iter in iters:
				self.entrystore.remove_entry(iter)

			self.undoqueue.add_action(
				"Remove entry", self.__cb_undo_remove, self.__cb_redo_remove,
				undoactions
			)

			self.tree.unselect_all()
			self.__file_autosave()
			self.statusbar.set_status("Entries removed")

		except dialog.CancelError:
			self.statusbar.set_status("Entry removal cancelled")


	def file_change_password(self, password = None):
		"Changes the password of the current data file"

		try:
			if password == None:
				password = dialog.PasswordChange(self, self.datafile.get_password()).run()

			self.datafile.set_password(password)
			self.entrystore.changed = True

			self.__file_autosave()
			self.statusbar.set_status("Password changed")

		except dialog.CancelError:
			self.statusbar.set_status("Password change cancelled")


	def file_export(self):
		"Exports data to a foreign file format"

		try:
			file, handler = dialog.ExportFileSelector(self).run()
			datafile = io.DataFile(handler)
			self.__file_save(file, None, datafile)

			self.statusbar.set_status("Data exported to %s" % datafile.get_file())

		except dialog.CancelError:
			self.statusbar.set_status("Export cancelled")


	def file_import(self):
		"Imports data from a foreign file"

		try:
			file, handler = dialog.ImportFileSelector(self).run()
			datafile = io.DataFile(handler)
			entrystore = self.__file_load(file, None, datafile)

			if entrystore is not None:
				newiters = self.entrystore.import_entry(entrystore, None)
				paths = [ self.entrystore.get_path(iter) for iter in newiters ]

				self.undoqueue.add_action(
					"Import data", self.__cb_undo_import, self.__cb_redo_import,
					( paths, entrystore )
				)

				self.statusbar.set_status("Data imported from %s" % datafile.get_file())

			self.__file_autosave()

		except dialog.CancelError:
			self.statusbar.set_status("Import cancelled")


	def file_lock(self):
		"Locks the current file"

		password = self.datafile.get_password()

		if password is None:
			return

		self.locktimer.stop()

		# TODO can this be done more elegantly?
		transients = [ window for window in gtk.window_list_toplevels() if window.get_transient_for() == self ]

		# store current state
		activeiter = self.tree.get_active()
		oldtitle = self.get_title()

		# clear application contents
		self.tree.set_model(None)
		self.entryview.clear()
		self.set_title("[Locked]")
		self.statusbar.set_status("File locked")

		# hide any dialogs
		for window in transients:
			window.hide()

		# lock file
		try:
			d = dialog.PasswordLock(self, password)

			if self.entrystore.changed == True:
				d.get_button(1).set_sensitive(False)

			d.run()

		except dialog.CancelError:
			self.quit()

		# unlock the file and restore state
		self.tree.set_model(self.entrystore)
		self.tree.select(activeiter)
		self.set_title(oldtitle)
		self.statusbar.set_status("File unlocked")

		for window in transients:
			window.show()

		self.locktimer.start(self.config.get("file/autolock_timeout") * 60)


	def file_new(self):
		"Opens a new file"

		try:
			self.__save_changes(dialog.FileChangesNew)

			self.entrystore.clear()
			self.datafile.close()
			self.undoqueue.clear()
			self.statusbar.set_status("New file created")

		except dialog.CancelError:
			self.statusbar.set_status("New file cancelled")


	def file_open(self, file = None, password = None):
		"Opens a data file"

		try:
			self.__save_changes(dialog.FileChangesOpen)

			if file is None:
				file = dialog.OpenFileSelector(self).run()

			entrystore = self.__file_load(file, password)

			if entrystore is None:
				return

			self.entrystore.clear()
			self.entrystore.import_entry(entrystore, None)
			self.entrystore.changed = False
			self.undoqueue.clear()

			self.statusbar.set_status("Opened file %s" % self.datafile.get_file())

		except dialog.CancelError:
			self.statusbar.set_status("Open cancelled")


	def file_save(self, file = None, password = None):
		"Saves data to a file"

		try:
			if file is None:
				file = dialog.SaveFileSelector(self).run()

			self.__file_save(file, password)
			self.entrystore.changed = False
			self.statusbar.set_status("Data saved to file %s" % file)

			return True

		except dialog.CancelError:
			self.statusbar.set_status("Save cancelled")
			return False


	def prefs(self):
		"Displays the application preferences"

		if self.dialog_prefs != None:
			self.dialog_prefs.present()

		else:
			self.dialog_prefs = dialog.Preferences(self, self.config)
			self.dialog_prefs.connect("destroy", lambda w: setattr(self, "dialog_prefs", None))

			self.dialog_prefs.run()


	def pwcheck(self):
		"Displays the password checking dialog"

		if self.dialog_pwcheck != None:
			self.dialog_pwcheck.present()

		else:
			self.dialog_pwcheck = dialog.PasswordChecker(self)
			self.dialog_pwcheck.connect("destroy", lambda w: setattr(self, "dialog_pwcheck", None))

			self.dialog_pwcheck.run()


	def pwgen(self):
		"Displays the password generator dialog"

		if self.dialog_pwgen != None:
			self.dialog_pwgen.present()

		else:
			self.dialog_pwgen = dialog.PasswordGenerator(self, self.config)
			self.dialog_pwgen.connect("destroy", lambda w: setattr(self, "dialog_pwgen", None))

			self.dialog_pwgen.run()


	def quit(self):
		"Quits the application"

		try:
			self.__save_changes(dialog.FileChangesQuit)

			self.clipboard.clear()
			self.entryclipboard.clear()

			self.__save_state()

			gtk.main_quit()
			sys.exit(0)
			return True

		except dialog.CancelError:
			self.statusbar.set_status("Quit cancelled")
			return False


	def redo(self):
		"Redoes the previous action"

		action = self.undoqueue.get_redo_action()

		if action is None:
			return

		self.undoqueue.redo()
		self.statusbar.set_status("%s redone" % action[1])
		self.__file_autosave()


	def run(self):
		"Runs the application"

		args, argdict = self.program.get_popt_args()

		if len(args) > 0:
			file = args[0]

		elif self.config.get("file/autoload") == True:
			file = self.config.get("file/autoload_file")

		else:
			file = ""


		if file != "":
			self.file_open(io.file_normpath(file))

		gtk.main()


	def undo(self):
		"Undoes the previous action"

		action = self.undoqueue.get_undo_action()

		if action is None:
			return

		self.undoqueue.undo()
		self.statusbar.set_status("%s undone" % action[1])
		self.__file_autosave()



if __name__ == "__main__":
	app = Revelation()
	app.run()

